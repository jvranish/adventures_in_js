(function() {
  var Server,
    __slice = [].slice;

  Server = (function() {
    function Server(adapter, turnManager, serverMessageFactory, syncManager, loggingConfig) {
      var m;
      this.adapter = adapter;
      this.turnManager = turnManager;
      this.serverMessageFactory = serverMessageFactory;
      this.syncManager = syncManager;
      this.loggingConfig = loggingConfig;
      m = this.serverMessageFactory;
      this.turnManager.on('turn_ended', (function(_this) {
        return function(currentTurn) {
          _this._broadcast(m.turnComplete(currentTurn));
          return _this.syncManager.turnEnded(currentTurn);
        };
      })(this));
      this.adapter.on('Network::PeerConnected', (function(_this) {
        return function(id) {
          var stateProviderId;
          _this._logIncoming("Network::PeerConnected", id);
          _this._send(id, m.idAssigned(id));
          stateProviderId = _this._selectOtherPlayer(id);
          _this._logDebug("Selected player " + stateProviderId + " to SEND STATE TO newcomer " + id + ")");
          if (_this.adapter.clientCount() === 1) {
            _this.turnManager.start();
          }
          _this._send(stateProviderId, m.gamestateRequest(id));
          return _this._broadcast(m.playerJoined(id));
        };
      })(this));
      this.adapter.on('Network::PeerDisconnected', (function(_this) {
        return function(id) {
          _this._logIncoming("Network::PeerDisconnected", id);
          if (_this.adapter.clientCount() === 0) {
            _this.turnManager.stop();
            _this.turnManager.reset();
          }
          return _this._broadcast(m.playerLeft(id));
        };
      })(this));
      this.adapter.on('Network::PeerPacket', (function(_this) {
        return function(id, data) {
          var msg;
          msg = _this._unpackClientMessage(data);
          switch (msg.type) {
            case 'ClientMsg::Event':
              _this._logIncoming('ClientMsg::Event', msg.data);
              return _this._broadcast(m.event(id, msg.data));
            case 'ClientMsg::Gamestate':
              _this._logIncoming('ClientMsg::Gamestate', msg.forPlayerId);
              return _this._send(msg.forPlayerId, m.startGame(msg.forPlayerId, _this.turnManager.period, _this.turnManager.current, msg.protoTurn, msg.simState, msg.worldState));
            case 'ClientMsg::TurnFinished':
              _this._logIncoming('ClientMsg::TurnFinished', msg.turnNumber, msg.checksum);
              return _this.syncManager.gotChecksum({
                playerId: id,
                turnNumber: msg.turnNumber,
                checksum: msg.checksum,
                clientIds: _this.adapter.clientIds.slice(0),
                defaultProviderId: _this.adapter.clientIds[0],
                resync: function(fromId, toId) {
                  _this._logDebug("SENDING STATE from: " + fromId + " -> " + toId);
                  return _this._send(fromId, m.gamestateRequest(toId));
                }
              });
          }
        };
      })(this));
    }

    Server.prototype._send = function(id, msg) {
      this._logOutgoing(msg.type, msg);
      return this.adapter.send(id, this._packServerMessage(msg));
    };

    Server.prototype._broadcast = function(msg) {
      this._logOutgoing(msg.type, "(BROADCAST)", msg);
      return this.adapter.broadcast(this._packServerMessage(msg));
    };

    Server.prototype._unpackClientMessage = function(msg) {
      return msg;
    };

    Server.prototype._packServerMessage = function(msg) {
      return msg;
    };

    Server.prototype._selectOtherPlayer = function(id) {
      if (this.adapter.clientCount() === 1) {
        return id;
      }
      if (this.adapter.clientIds[0] !== id) {
        return this.adapter.clientIds[0];
      } else {
        return this.adapter.clientids[1];
      }
    };

    Server.prototype._log = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return console.log.apply(console, ["=== Server:"].concat(__slice.call(args)));
    };

    Server.prototype._logDebug = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.loggingConfig.debug) {
        return this._log.apply(this, args);
      }
    };

    Server.prototype._logIncoming = function() {
      var args, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.loggingConfig.incomingMessages && (_ref = this.loggingConfig).allowMessage.apply(_ref, args)) {
        return console.log.apply(console, [">>> Server RECV:"].concat(__slice.call(args)));
      }
    };

    Server.prototype._logOutgoing = function() {
      var args, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.loggingConfig.outgoingMessages && (_ref = this.loggingConfig).allowMessage.apply(_ref, args)) {
        return console.log.apply(console, ["<<< Server SEND:"].concat(__slice.call(args)));
      }
    };

    return Server;

  })();

  module.exports = Server;

}).call(this);
